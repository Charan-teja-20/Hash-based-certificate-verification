<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Certificate DApp with IPFS</title>
  <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-1: #0b0b1a;
      --bg-2: #111133;
      --glass: rgba(255,255,255,0.05);
      --glass-2: rgba(255,255,255,0.08);
      --border: rgba(255,255,255,0.15);
      --txt: #eaf4ff;
      --muted: #b7c3d9;
      --pri: #69e0ff;
      --sec: #b47dff;
      --acc: #ffe26d;
      --good: #69f0ae;
      --bad: #ff6e9e;
      --shadow: 0 20px 60px rgba(0,0,0,.55);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; color: var(--txt); background: radial-gradient(1200px 800px at 80% -10%, #1b0f34 0%, transparent 70%), radial-gradient(900px 700px at -10% 110%, #0d2238 0%, transparent 60%), linear-gradient(180deg, var(--bg-1), var(--bg-2));
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow-x: hidden; padding: 22px;
    }

    #particles-js { position: fixed; inset: 0; z-index: -1; }

    .halo {
      position: fixed; inset: -20%; z-index: -2; filter: blur(60px) saturate(1.2) opacity(.6);
      background: radial-gradient(600px 400px at 20% 30%, #00b3ff33, transparent 60%),
                  radial-gradient(700px 420px at 80% 70%, #b47dff33, transparent 60%),
                  radial-gradient(800px 420px at 40% 90%, #ffe26d22, transparent 60%);
      pointer-events: none;
    }

    h1 {
      font-size: clamp(28px, 4vw, 44px);
      line-height: 1.1; margin: 6px 0 14px; font-weight: 800; letter-spacing: -0.02em;
      text-shadow: 0 0 14px #00b3ff44, 0 0 26px #b47dff33;
    }
    .subtitle { opacity: .8; margin-bottom: 18px; }

    .stack { max-width: 1024px; margin: 0 auto; display: grid; gap: 18px; }

    .card {
      background: linear-gradient(180deg, var(--glass), var(--glass-2));
      border: 1px solid var(--border); border-radius: 20px; padding: 20px; box-shadow: var(--shadow);
      backdrop-filter: blur(14px); -webkit-backdrop-filter: blur(14px);
    }

    .tabs { display: flex; gap: 8px; border-bottom: 1px solid var(--border); padding-bottom: 8px; overflow: auto; }
    .tab { appearance: none; border: 0; background: transparent; color: var(--muted); padding: 10px 14px; border-radius: 12px; font-weight: 600; cursor: pointer; position: relative; }
    .tab.active { color: var(--pri); background: #69e0ff14; }
    .tab::after { content: ""; position: absolute; left: 12px; right: 12px; bottom: -9px; height: 3px; background: linear-gradient(90deg, var(--pri), var(--sec)); border-radius: 2px; transform: scaleX(0); transition: .25s; }
    .tab.active::after { transform: scaleX(1); }

    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 820px) { .grid-2 { grid-template-columns: 1fr; } }

    .btn {
      width: 100%; padding: 14px 16px; border-radius: 14px; border: 1px solid var(--border); background: #ffffff08; color: var(--txt);
      font-weight: 700; cursor: pointer; letter-spacing: .2px; position: relative; overflow: hidden; transition: transform .18s ease;
      box-shadow: inset 0 0 0 1px #ffffff0a, 0 8px 30px #00000055;
    }
    .btn:hover { transform: translateY(-2px); }
    .btn[disabled] { opacity: .6; cursor: not-allowed; filter: grayscale(.2); }

    .btn-primary { border: 1px solid #51d3ff; background: linear-gradient(180deg, #9be8ff33, #51d3ff22); }
    .btn-primary .shine { position: absolute; inset: 0; background: linear-gradient(120deg, transparent 0%, #ffffff55 30%, transparent 60%); transform: translateX(-120%); }
    .btn-primary:hover .shine { animation: shine 1.2s ease; }
    @keyframes shine { from { transform: translateX(-120%);} to { transform: translateX(120%);} }

    .btn-acc { border: 1px solid #ffe26d; background: linear-gradient(180deg, #fff1b633, #ffe26d22); }

    .status { font-weight: 700; opacity: .9; }

    input[type="file"], input[type="text"], input[type="number"], .input {
      margin: 10px 0; padding: 14px; width: 100%; border-radius: 12px; border: 1px solid var(--border); font-size: 16px;
      background: #0f1533; color: var(--txt); outline: none; box-shadow: inset 0 0 0 1px #ffffff0c; transition: box-shadow .2s, border .2s;
      font-family: inherit;
    }
    input:focus { border-color: #69e0ff88; box-shadow: 0 0 0 4px #69e0ff22; }

    .muted { color: var(--muted); }
    .mono { font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12.5px; }

    #notification { position: fixed; left: 50%; transform: translateX(-50%); top: -120px; background: #101630cc; border: 1px solid var(--border); padding: 14px 18px; border-radius: 12px; z-index: 1000; transition: top .45s ease; box-shadow: var(--shadow); font-weight: 700; }
    #notification.error { border-color: var(--bad); color: #ffd7e5; text-shadow: 0 0 6px #ff6e9e66; }

    .pill { display: inline-flex; align-items:center; gap: 8px; padding: 8px 12px; border: 1px solid var(--border); border-radius: 999px; background: #ffffff08; }

    /* Dropzone */
    .dropzone { border: 1.5px dashed #69e0ff77; border-radius: 14px; padding: 16px; text-align: center; cursor: pointer; background: #0e1431; }
    .dropzone.drag { background: #0e1431; box-shadow: 0 0 0 4px #69e0ff22; }

    /* Table */
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 10px; border: 1px solid var(--border); }
    th { background: #69e0ff1a; }

    /* Modal */
    .modal-backdrop { position: fixed; inset: 0; background: #0008; display: none; align-items: center; justify-content: center; z-index: 2000; }
    .modal { width: min(560px, 92vw); background: linear-gradient(180deg, #0d1030, #12143a); border: 1px solid var(--border); border-radius: 18px; padding: 20px; box-shadow: var(--shadow); }
    .modal h3 { margin-top: 0; }
    .modal-actions { display: flex; gap: 10px; margin-top: 10px; }
    .badge { font-size: 12px; padding: 4px 8px; border-radius: 999px; background: #ffffff14; border: 1px solid var(--border); }

    /* QR */
    .qr-section { margin-top: 18px; border-top: 1px dashed var(--border); padding-top: 12px; display: none; text-align: center; }
    #qrCanvas { background: white; padding: 10px; border-radius: 10px; display: inline-block; }

    /* Diagnostics */
    details.diag { margin-top: 10px; }
    details.diag summary { cursor: pointer; }
  </style>
</head>
<body>
  <div id="particles-js"></div>
  <div class="halo"></div>

  <div class="stack">
    <header>
      <h1>Advanced Certificate DApp</h1>
      <div class="subtitle muted">Issue, batch-issue, and verify certificates with on‚Äëchain proofs and IPFS storage.</div>
      <div class="grid-2">
        <button id="connectButton" class="btn btn-acc">
          <span class="shine"></span>üîó Connect Wallet
        </button>
        <button id="settingsButton" class="btn" title="Pinata / Preferences">‚öôÔ∏è Settings</button>
      </div>
      <div id="status" class="status pill" style="margin-top:10px">üîå Wallet not connected</div>
      <details class="diag"><summary class="pill" style="margin-top:8px">üß™ Diagnostics & Self‚ÄëTests</summary>
        <div id="diag" class="mono" style="margin-top:8px"></div>
      </details>
    </header>

    <section class="card">
      <nav class="tabs">
        <button class="tab active" data-tab="issue">Issue Single</button>
        <button class="tab" data-tab="batch">Issue Batch</button>
        <button class="tab" data-tab="verify">Verify</button>
        <button class="tab" data-tab="history">My History</button>
        <button id="admin-tab" class="tab" data-tab="admin" style="display:none">Admin Panel</button>
      </nav>

      <div id="tab-issue" class="tab-pane">
        <h2>Issue a New Certificate</h2>
        <label class="dropzone" id="dropzone">
          <input type="file" id="fileInput" accept=".pdf,.png,.jpg,.jpeg" style="display:none" />
          <div>üìÑ Drag & drop certificate file here or click to upload</div>
        </label>
        <input type="text" id="hashInput" placeholder="Hash (auto-generated from file)" readonly />
        <div class="grid-2">
          <input type="text" id="recipientName" placeholder="Recipient's Name" />
          <input type="text" id="courseTitle" placeholder="Course or Achievement" />
        </div>
        <input type="number" id="grade" placeholder="Grade / Score (0-100)" min="0" max="100" />
        <button id="issueCertBtn" class="btn btn-primary">‚ú® Issue Certificate <span class="shine"></span></button>
        <div class="muted mono" style="margin-top:8px">Stored on IPFS via Pinata; proof written to your smart contract.</div>
      </div>

      <div id="tab-batch" class="tab-pane" style="display:none">
        <h2>Batch Issue Certificates</h2>
        <p class="muted">Add rows manually or upload a CSV with headers: <span class="badge mono">hash</span> <span class="badge mono">recipientName</span> <span class="badge mono">courseTitle</span> <span class="badge mono">grade</span> <span class="badge mono">ipfsCid</span></p>
        <div class="grid-2">
          <input type="text" id="batchRecipientName" placeholder="Recipient's Name" />
          <input type="text" id="batchCourseTitle" placeholder="Course Title" />
          <input type="text" id="batchHash" placeholder="Certificate Hash" />
          <input type="number" id="batchGrade" placeholder="Grade" />
        </div>
        <div class="grid-2">
          <button id="addToBatchBtn" class="btn">‚ûï Add Entry Manually</button>
          <label for="csvFileInput" class="btn">üßæ Upload CSV File</label>
          <input type="file" id="csvFileInput" accept=".csv" style="display:none" />
        </div>
        <div id="batch-table-container" class="card" style="margin-top:10px">
          <table id="batch-table">
            <thead><tr><th>Recipient</th><th>Course</th><th>Hash</th><th>Grade</th><th>IPFS CID</th><th>Action</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
        <button id="issueBatchBtn" class="btn btn-primary" style="margin-top: 12px;">üöÄ Issue Entire Batch <span class="shine"></span></button>
      </div>

      <div id="tab-verify" class="tab-pane" style="display:none">
        <h2>Verify a Certificate</h2>
        <input type="text" id="verifyHashInput" placeholder="Enter Certificate Hash to Verify" />
        <button id="verifyBtn" class="btn">üîç Verify Certificate</button>
        <div id="verificationResult" class="card" style="margin-top: 12px; display:none"></div>
        <div class="qr-section" id="qrSection">
          <canvas id="qrCanvas"></canvas>
          <div style="margin-top:8px; display:flex; gap:8px; justify-content:center">
            <button id="copyLinkBtn" class="btn" style="width:auto">üìã Copy Link</button>
            <button id="downloadQRBtn" class="btn" style="width:auto">‚¨áÔ∏è Download QR</button>
            <button id="shareQRBtn" class="btn" style="width:auto">üì§ Share QR</button>
          </div>
        </div>
      </div>

      <div id="tab-history" class="tab-pane" style="display:none">
        <h2>My Issued Certificates</h2>
        <input type="text" id="historySearch" placeholder="üîç Search by recipient or course..." />
        <div class="grid-2">
          <button id="refreshHistoryBtn" class="btn">üîÑ Refresh History</button>
          <div class="pill">Tip: type to filter instantly</div>
        </div>
        <div id="myCertsList" class="card" style="margin-top:10px">Your issued certificates will appear here...</div>
      </div>

      <div id="tab-admin" class="tab-pane" style="display:none">
        <h2>Owner Admin Panel</h2>
        <p class="muted">Grant or revoke the ability for an address to issue certificates.</p>
        <input type="text" id="issuerAddress" placeholder="Enter address (e.g., 0x...)" />
        <div class="grid-2">
          <button id="grantRoleBtn" class="btn">Grant Issuer Role</button>
          <button id="revokeRoleBtn" class="btn" style="border-color:#ff6e9e;">Revoke Issuer Role</button>
        </div>
      </div>
    </section>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal-backdrop" aria-hidden="true" role="dialog">
    <div class="modal">
      <h3>Preferences & Pinata</h3>
      <p class="muted" style="margin-top:-6px">Paste your <strong>Pinata JWT (Secret Access Token)</strong>. Stored locally in your browser (optional). Never share it publicly.</p>
      <input type="password" id="pinataJwtInput" class="input" placeholder="eyJhbGciOi... (JWT)" autocomplete="off" />
      <div class="modal-actions">
        <button id="testPinataBtn" class="btn">üß™ Test Connection</button>
        <button id="savePinataBtn" class="btn btn-primary"><span class="shine"></span>üíæ Save to Browser</button>
        <button id="clearPinataBtn" class="btn">üóëÔ∏è Clear</button>
        <button id="closeSettingsBtn" class="btn">‚úñ Close</button>
      </div>
      <div id="pinataTestStatus" class="muted mono" style="margin-top:8px"></div>
      <div class="muted mono" style="margin-top:8px">Need MetaMask on mobile? <a id="mmDeepLink" href="#" target="_blank" style="color:var(--pri); font-weight:700">Open in MetaMask</a></div>
    </div>
  </div>

  <!-- No-Provider Modal -->
  <div id="noProviderModal" class="modal-backdrop" aria-hidden="true" role="dialog">
    <div class="modal">
      <h3>Wallet Not Detected</h3>
      <p class="muted">I couldn't find an injected Ethereum provider. Install MetaMask or open this page in the MetaMask mobile app.</p>
      <div class="modal-actions">
        <a id="installLink" class="btn" href="https://metamask.io/download/" target="_blank">‚¨áÔ∏è Install MetaMask</a>
        <a id="openInMM" class="btn btn-primary" target="_blank"><span class="shine"></span>üì± Open in MetaMask</a>
        <button id="closeNoProviderBtn" class="btn">‚úñ Close</button>
      </div>
      <div class="muted mono" id="noProviderHint"></div>
    </div>
  </div>

  <div id="notification"></div>

  <script>
    // ================= USER CONFIG (replace placeholders) =================
    const contractAddress = "0xb01674FeC93b32cA63c6D18994B00a2d1352D7eF"; // REPLACE
    const abi = [
	{
		"inputs": [
			{
				"internalType": "bytes32[]",
				"name": "certHashes",
				"type": "bytes32[]"
			},
			{
				"internalType": "string[]",
				"name": "recipientNames",
				"type": "string[]"
			},
			{
				"internalType": "string[]",
				"name": "courseTitles",
				"type": "string[]"
			},
			{
				"internalType": "uint8[]",
				"name": "grades",
				"type": "uint8[]"
			},
			{
				"internalType": "string[]",
				"name": "_ipfsCids",
				"type": "string[]"
			}
		],
		"name": "batchIssueCertificates",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "OwnableInvalidOwner",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "OwnableUnauthorizedAccount",
		"type": "error"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "bytes32",
				"name": "certHash",
				"type": "bytes32"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "issuer",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "recipientName",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "courseTitle",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "ipfsCid",
				"type": "string"
			}
		],
		"name": "CertificateIssued",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "bytes32",
				"name": "certHash",
				"type": "bytes32"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "issuer",
				"type": "address"
			}
		],
		"name": "CertificateRevoked",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_account",
				"type": "address"
			}
		],
		"name": "grantIssuerRole",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes32",
				"name": "certHash",
				"type": "bytes32"
			},
			{
				"internalType": "string",
				"name": "recipientName",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "courseTitle",
				"type": "string"
			},
			{
				"internalType": "uint8",
				"name": "grade",
				"type": "uint8"
			},
			{
				"internalType": "string",
				"name": "_ipfsCid",
				"type": "string"
			}
		],
		"name": "issueCertificate",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "IssuerGranted",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "IssuerRevoked",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "previousOwner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "OwnershipTransferred",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "renounceOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes32",
				"name": "certHash",
				"type": "bytes32"
			}
		],
		"name": "revokeCertificate",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_account",
				"type": "address"
			}
		],
		"name": "revokeIssuerRole",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "transferOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes32",
				"name": "certHash",
				"type": "bytes32"
			}
		],
		"name": "getCertificateDetails",
		"outputs": [
			{
				"components": [
					{
						"internalType": "address",
						"name": "issuer",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "issueDate",
						"type": "uint256"
					},
					{
						"internalType": "bool",
						"name": "isValid",
						"type": "bool"
					},
					{
						"internalType": "string",
						"name": "recipientName",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "courseTitle",
						"type": "string"
					},
					{
						"internalType": "uint8",
						"name": "grade",
						"type": "uint8"
					},
					{
						"internalType": "string",
						"name": "ipfsCid",
						"type": "string"
					}
				],
				"internalType": "struct CertificateRegistryV2.Certificate",
				"name": "",
				"type": "tuple"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_issuer",
				"type": "address"
			}
		],
		"name": "getCertificatesByIssuer",
		"outputs": [
			{
				"internalType": "bytes32[]",
				"name": "",
				"type": "bytes32[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "isIssuer",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
]; // REPLACE
    // Optional: set the network your contract is deployed on to enforce/offer network switching
    // Example Polygon mainnet: { chainId: '0x89', chainName: 'Polygon', rpcUrls: ['https://polygon-rpc.com/'], blockExplorerUrls: ['https://polygonscan.com'] }
    const NETWORK = { chainId: '', chainName: '', rpcUrls: [], blockExplorerUrls: [] };
    // =====================================================================

    let web3, account, contract, contractOwner, ethProvider;
    let batchToIssue = [];
    let pinataJwt = ''; // managed via Settings modal / localStorage

    // ---------------------- UTILities & UI ----------------------
    function qs(sel){ return document.querySelector(sel); }
    function qsa(sel){ return [...document.querySelectorAll(sel)]; }

    function showNotification(message, isError = false) {
      const n = document.getElementById('notification');
      n.textContent = message; n.className = isError ? 'error' : ''; n.style.top = '20px';
      clearTimeout(showNotification._t);
      showNotification._t = setTimeout(()=>{ n.style.top = '-120px'; }, 4200);
    }

    function setButtonProcessing(buttonEl, isProcessing, textWhenIdle){
      if(!buttonEl) return;
      if(isProcessing){ buttonEl.disabled = true; buttonEl.dataset.prev = buttonEl.textContent; buttonEl.textContent = '‚è≥ Processing...'; }
      else { buttonEl.disabled = false; buttonEl.textContent = textWhenIdle || buttonEl.dataset.prev || 'Done'; }
    }

    function switchTab(to){
      qsa('.tab').forEach(b=>b.classList.toggle('active', b.dataset.tab===to));
      qsa('.tab-pane').forEach(p=>p.style.display = 'none');
      const pane = qs(`#tab-${to}`); if(pane) pane.style.display = '';
    }

    function isMobile(){ return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent); }

    function metamaskDeepLink(){
      const host = location.host || 'yourdomain.com';
      const path = location.pathname + location.search + location.hash;
      return `https://metamask.app.link/dapp/${host}${path}`;
    }

    // Select the best injected provider (MetaMask preferred, but support others too)
    function selectEthereumProvider(){
      const eth = window.ethereum; if(!eth) return null;
      if (Array.isArray(eth.providers) && eth.providers.length){
        const mm = eth.providers.find(p=>p.isMetaMask);
        return mm || eth.providers[0];
      }
      return eth;
    }

    async function ensureCorrectNetwork(){
      if(!ethProvider) return true;
      try{
        const current = await ethProvider.request({ method: 'eth_chainId' });
        if(NETWORK.chainId && current.toLowerCase() !== NETWORK.chainId.toLowerCase()){
          try{
            await ethProvider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: NETWORK.chainId }] });
            return true;
          }catch(e){
            if(e.code === 4902 && NETWORK.chainName && NETWORK.rpcUrls?.length){
              // Chain not added ‚Äî try adding
              await ethProvider.request({ method: 'wallet_addEthereumChain', params: [NETWORK] });
              return true;
            }
            // Unable to switch; inform user
            showNotification(`Please switch your wallet to ${NETWORK.chainName || 'the correct network'}.`, true);
            throw e;
          }
        }
        return true;
      }catch(e){ console.warn('Network check failed', e); return true; }
    }

    // ---------------------- Wallet ----------------------
    async function connectWallet(){
      const btn = qs('#connectButton'); setButtonProcessing(btn, true);
      try {
        if (contractAddress === '0xYOUR_NEW_SMART_CONTRACT_ADDRESS' || !Array.isArray(abi) || abi.length === 0){
          showNotification('Error: Smart Contract Address or ABI is not set.', true); return;
        }

        const provider = selectEthereumProvider();
        if(!provider){
          // no injected provider ‚Äî guide the user
          const noProv = qs('#noProviderModal');
          const link = metamaskDeepLink();
          qs('#openInMM').href = link; qs('#mmDeepLink').href = link;
          qs('#noProviderHint').textContent = isMobile()
            ? 'Tap "Open in MetaMask" to launch the DApp inside the MetaMask app.'
            : 'Install the MetaMask extension and refresh this page.';
          noProv.style.display = 'flex';
          showNotification('Wallet not detected.', true);
          return;
        }

        ethProvider = provider; // keep globally
        web3 = new Web3(ethProvider);

        // Request accounts (handle common MetaMask error codes)
        try{
          const accounts = await ethProvider.request({ method: 'eth_requestAccounts' });
          account = accounts?.[0];
        }catch(e){
          if (e && (e.code === -32002)){
            showNotification('Connection request already pending in MetaMask. Please open the wallet and approve.', true);
          } else if (e && (e.code === 4001)){
            showNotification('Connection rejected in wallet.', true);
          } else {
            showNotification('Failed to connect to wallet: ' + (e?.message || e), true);
          }
          return;
        }

        if(!account){ showNotification('No account returned by wallet.', true); return; }

        await ensureCorrectNetwork();

        contract = new web3.eth.Contract(abi, contractAddress);
        const connectedAddressDisplay = account; // ENS optional
        qs('#connectButton').innerHTML = '‚úÖ Wallet Connected';
        qs('#status').innerHTML = `üü¢ Connected: ${connectedAddressDisplay.substring(0, 15)}...`;

        // Provider events
        if (ethProvider && ethProvider.on){
          ethProvider.on('accountsChanged', (accs)=>{
            if(!accs || !accs.length){ location.reload(); return; }
            account = accs[0];
            qs('#status').innerHTML = `üü¢ Connected: ${account.substring(0, 15)}...`;
            fetchIssuedCertificates();
          });
          ethProvider.on('chainChanged', ()=>{ location.reload(); });
        }

        await checkUserRole();
        await fetchIssuedCertificates();
        if(!pinataJwt){ openSettings('Tip: add your Pinata JWT to enable IPFS uploads.'); }
      } catch(e) {
        console.error(e);
        showNotification('Connection failed: ' + (e?.message || e), true);
      } finally {
        setButtonProcessing(btn, false, 'üîó Connect Wallet');
      }
    }

    async function getEnsName(address){ return null; }

    async function checkUserRole(){
      if(!contract) return;
      try{
        contractOwner = await contract.methods.owner().call();
        const isAdmin = account.toLowerCase() === contractOwner.toLowerCase();
        qs('#admin-tab').style.display = isAdmin ? 'inline-flex' : 'none';
      }catch(e){ console.error('Role check failed', e); }
    }

    // ---------------------- Pinata / IPFS ----------------------
    function loadPinataFromStorage(){
      const saved = localStorage.getItem('pinataJwt');
      if(saved){ pinataJwt = saved; }
    }

    function openSettings(info){
      const modal = qs('#settingsModal');
      modal.style.display = 'flex';
      qs('#pinataJwtInput').value = pinataJwt || '';
      qs('#pinataTestStatus').textContent = info || '';
      const link = metamaskDeepLink();
      qs('#mmDeepLink').href = link;
    }

    function closeSettings(){ qs('#settingsModal').style.display = 'none'; }

    async function testPinata(){
      const btn = qs('#testPinataBtn');
      const jwt = qs('#pinataJwtInput').value.trim();
      if(!jwt){ qs('#pinataTestStatus').textContent = 'Enter a JWT first.'; return; }
      setButtonProcessing(btn, true);
      try{
        const res = await fetch('https://api.pinata.cloud/data/testAuthentication', { headers: { Authorization: `Bearer ${jwt}` } });
        if(!res.ok){ throw new Error('Auth failed: HTTP ' + res.status); }
        await res.json();
        qs('#pinataTestStatus').textContent = '‚úÖ Pinata authentication OK.';
      }catch(err){
        qs('#pinataTestStatus').textContent = '‚ùå ' + err.message;
      }finally{ setButtonProcessing(btn, false, 'üß™ Test Connection'); }
    }

    function savePinata(){
      const jwt = qs('#pinataJwtInput').value.trim();
      if(!jwt){ showNotification('Nothing to save. Paste a JWT.', true); return; }
      pinataJwt = jwt; localStorage.setItem('pinataJwt', pinataJwt);
      showNotification('üîê Pinata JWT saved locally.');
    }

    function clearPinata(){ localStorage.removeItem('pinataJwt'); pinataJwt=''; qs('#pinataJwtInput').value=''; showNotification('üßπ Cleared saved JWT.'); }

    async function uploadToIPFS(file){
      if (!pinataJwt){ showNotification('Pinata JWT not set. Open Settings and paste your token.', true); return null; }
      showNotification('üõ∞Ô∏è Uploading file to IPFS via Pinata...');
      const formData = new FormData(); formData.append('file', file);
      try{
        const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', { method:'POST', headers:{ Authorization: `Bearer ${pinataJwt}` }, body: formData });
        if(!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const resData = await response.json();
        showNotification('‚úÖ File pinned to IPFS successfully!');
        return resData.IpfsHash;
      }catch(error){ console.error('IPFS Upload Error:', error); showNotification('‚ùå IPFS Upload Error: ' + error.message, true); return null; }
    }

    // ---------------------- Single Issue ----------------------
    async function generateHashFromFile(file){
      const ab = await file.arrayBuffer();
      const hb = await crypto.subtle.digest('SHA-256', ab);
      const ha = Array.from(new Uint8Array(hb));
      return '0x' + ha.map(b=>b.toString(16).padStart(2,'0')).join('');
    }

    async function handleFileChosen(file){
      if(!file) return; showNotification('Hashing file...');
      const hh = await generateHashFromFile(file);
      qs('#hashInput').value = hh; showNotification('üìÑ Hash generated successfully!');
      qs('#fileInput')._fileRef = file; // keep a ref for upload
    }

    async function issueCert(){
      if (!contract) { showNotification('Please connect wallet.', true); return; }
      const fileRef = qs('#fileInput')._fileRef; if(!fileRef){ showNotification('Please choose a certificate file.', true); return; }
      const issueBtn = qs('#issueCertBtn'); setButtonProcessing(issueBtn, true);
      const ipfsCid = await uploadToIPFS(fileRef); if(!ipfsCid){ setButtonProcessing(issueBtn, false, '‚ú® Issue Certificate'); return; }

      const hash = qs('#hashInput').value.trim();
      const recipientName = qs('#recipientName').value.trim();
      const courseTitle = qs('#courseTitle').value.trim();
      const grade = qs('#grade').value;
      if (!hash || !recipientName || !courseTitle || grade === ''){ setButtonProcessing(issueBtn, false, '‚ú® Issue Certificate'); showNotification('Please fill all fields.', true); return; }

      showNotification('üöÄ Sending transaction to issue certificate...');
      try{
        await contract.methods.issueCertificate(hash, recipientName, courseTitle, grade, ipfsCid).send({ from: account });
        showNotification('‚ú® Certificate permanently recorded on-chain!');
        fetchIssuedCertificates();
      }catch(e){ showNotification('‚ùå Transaction Error: ' + e.message, true); }
      finally{ setButtonProcessing(issueBtn, false, '‚ú® Issue Certificate'); }
    }

    // ---------------------- Verify ----------------------
    async function verifyCert(){
      if (!contract) { showNotification('Please connect wallet.', true); return; }
      const hash = qs('#verifyHashInput').value.trim();
      if (!hash){ showNotification('Please enter a hash to verify.', true); return; }
      const resultDiv = qs('#verificationResult'); const qrSection = qs('#qrSection');
      resultDiv.style.display = 'none'; qrSection.style.display = 'none';
      try{
        const certDetails = await contract.methods.getCertificateDetails(hash).call();
        const issuerDisplay = await getEnsName(certDetails.issuer) || certDetails.issuer;
        resultDiv.style.display = 'block';
        const valid = !!certDetails.isValid;
        resultDiv.innerHTML = `
          <h3 style="color:${valid?'var(--good)':'var(--bad)'}">${valid ? '‚úÖ VALID CERTIFICATE' : '‚ùå CERTIFICATE REVOKED'}</h3>
          <p><strong>Recipient:</strong> ${certDetails.recipientName}</p>
          <p><strong>Achievement:</strong> ${certDetails.courseTitle}</p>
          <p><strong>Grade/Score:</strong> ${certDetails.grade}</p>
          <p><strong>Issued By:</strong> <span class="mono">${issuerDisplay}</span></p>
          <p><strong>Issue Date:</strong> ${new Date(Number(certDetails.issueDate) * 1000).toLocaleString()}</p>
          <p><strong>Permanent File Link:</strong> <a href="https://ipfs.io/ipfs/${certDetails.ipfsCid}" target="_blank" style="color:var(--pri); font-weight:700">View on IPFS</a></p>`;
        generateQRCode(hash); qrSection.style.display = 'block';
      }catch(e){
        resultDiv.style.display = 'block';
        resultDiv.innerHTML = `<h3 style="color: var(--acc);">‚ö†Ô∏è NOT FOUND</h3><p>This certificate hash does not exist in the registry.</p>`;
      }
    }

    function generateQRCode(text){ const c = qs('#qrCanvas'); QRCode.toCanvas(c, text, { width: 180, margin: 2, color: { dark: '#1a0f35', light: '#ffffff' } }, (err)=>{ if(err) console.error(err); }); }

    function copyLink(){ const h = qs('#verifyHashInput').value.trim(); if(!h) return showNotification('No hash to copy.', true); const url = `${window.location.origin}${window.location.pathname}?certHash=${h}`; navigator.clipboard.writeText(url); showNotification('üìã Link copied!'); }
    function downloadQR(){ const c = qs('#qrCanvas'); const link = document.createElement('a'); link.download = 'certificate-qr.png'; link.href = c.toDataURL('image/png'); link.click(); }
    async function shareQR(){ const c = qs('#qrCanvas'); c.toBlob(async (blob)=>{ const f = new File([blob], 'certificate-qr.png', { type: 'image/png' }); if(navigator.share && navigator.canShare({ files: [f] })){ try{ await navigator.share({ files:[f], title:'Certificate QR', text:'Scan to verify this certificate' }); }catch(e){ if(e.name !== 'AbortError') showNotification('Sharing failed.', true); } } else { showNotification('Web Share not supported on this device.', true); } }, 'image/png'); }

    async function fetchIssuedCertificates(){
      if (!contract) return;
      const ld = qs('#myCertsList'); ld.innerHTML = '<em>Loading...</em>';
      try{
        const ch = await contract.methods.getCertificatesByIssuer(account).call();
        if (ch.length === 0){ ld.innerHTML = 'You have not issued any certificates yet.'; return; }
        ld.innerHTML = '';
        for (const h of ch.slice().reverse()){
          const cd = await contract.methods.getCertificateDetails(h).call();
          const item = document.createElement('div'); item.className = 'cert-item';
          item.innerHTML = `<p data-recipient="${cd.recipientName}" data-course="${cd.courseTitle}"><strong>Recipient:</strong> ${cd.recipientName} | <strong>Course:</strong> ${cd.courseTitle}</p><p><strong>Status:</strong> ${cd.isValid ? `<span style='color:var(--good);'>Valid</span>` : `<span style='color:var(--bad);'>Revoked</span>`}</p>`;
          ld.appendChild(item);
        }
      }catch(e){ showNotification('Could not fetch history: ' + e.message, true); }
    }

    function filterHistory(){
      const searchTerm = qs('#historySearch').value.toLowerCase();
      const certs = qsa('#myCertsList .cert-item');
      certs.forEach(cert => {
        const p = cert.querySelector('p[data-recipient]');
        const recipient = p.dataset.recipient.toLowerCase();
        const course = p.dataset.course.toLowerCase();
        cert.style.display = (recipient.includes(searchTerm) || course.includes(searchTerm)) ? 'block' : 'none';
      });
    }

    function addToBatch(){
      const rn = qs('#batchRecipientName').value.trim();
      const ct = qs('#batchCourseTitle').value.trim();
      const h = qs('#batchHash').value.trim();
      const g = qs('#batchGrade').value;
      if(!rn || !ct || !h || g===''){ showNotification('Please fill all fields for the batch item.', true); return; }
      batchToIssue.push({ recipientName: rn, courseTitle: ct, hash: h, grade: g, ipfsCid: '' });
      renderBatchTable();
      ['#batchRecipientName','#batchCourseTitle','#batchHash','#batchGrade'].forEach(id=> qs(id).value='');
    }

    function renderBatchTable(){
      const tb = qs('#batch-table tbody'); tb.innerHTML = '';
      batchToIssue.forEach((item, index)=>{
        const row = tb.insertRow();
        row.innerHTML = `<td>${item.recipientName}</td><td>${item.courseTitle}</td><td class='mono' style='font-size:10px; word-break:break-all;'>${item.hash.substring(0,10)}...</td><td>${item.grade}</td><td class='mono'>${item.ipfsCid || '-'}</td><td><button class='btn' style='width:auto' data-index='${index}'>Remove</button></td>`;
        row.querySelector('button').onclick = ()=>{ batchToIssue.splice(index,1); renderBatchTable(); };
      });
    }

    async function issueBatch(){
      if (batchToIssue.length === 0) return showNotification('Batch is empty.', true);
      const missing = batchToIssue.filter(r=>!r.ipfsCid).length;
      if(missing>0){ showNotification(`Upload CIDs missing for ${missing} row(s). Provide ipfsCid in CSV.`, true); return; }
      try{
        showNotification('üöÄ Sending batch transactions...');
        for(const row of batchToIssue){
          await contract.methods.issueCertificate(row.hash, row.recipientName, row.courseTitle, row.grade, row.ipfsCid).send({ from: account });
        }
        showNotification('‚úÖ Batch complete!');
        batchToIssue = []; renderBatchTable(); fetchIssuedCertificates();
      }catch(e){ showNotification('‚ùå Batch Error: ' + e.message, true); }
    }

    function handleFileUpload(event){
      const f = event.target.files[0]; if(!f) return; Papa.parse(f, { header: true, skipEmptyLines: true, complete: function(res){
          const req = ['hash','recipientName','courseTitle','grade']; const act = res.meta.fields;
          if (!req.every(h => act.includes(h))){ showNotification('CSV headers must be: hash, recipientName, courseTitle, grade (optional ipfsCid)', true); return; }
          const rows = res.data.map(r => ({ ...r, ipfsCid: r.ipfsCid || '' }));
          batchToIssue = [...batchToIssue, ...rows]; renderBatchTable(); showNotification(`‚úÖ Loaded ${rows.length} records from CSV.`);
        }, error: function(err){ showNotification('CSV parsing error: ' + err.message, true); } });
      event.target.value='';
    }

    // ---------------------- Admin ----------------------
    async function grantRole(){
      if(!contract) return; const addr = qs('#issuerAddress').value.trim();
      if(!web3.utils.isAddress(addr)) return showNotification('Invalid Ethereum address.', true);
      const btn = qs('#grantRoleBtn'); setButtonProcessing(btn, true);
      try{ await contract.methods.grantIssuerRole(addr).send({ from: account }); showNotification('‚úÖ Role Granted!'); }
      catch(e){ showNotification('‚ùå Error: ' + e.message, true); }
      finally{ setButtonProcessing(btn, false, 'Grant Issuer Role'); }
    }

    async function revokeRole(){
      if(!contract) return; const addr = qs('#issuerAddress').value.trim();
      if(!web3.utils.isAddress(addr)) return showNotification('Invalid Ethereum address.', true);
      const btn = qs('#revokeRoleBtn'); setButtonProcessing(btn, true);
      try{ await contract.methods.revokeIssuerRole(addr).send({ from: account }); showNotification('‚úÖ Role Revoked!'); }
      catch(e){ showNotification('‚ùå Error: ' + e.message, true); }
      finally{ setButtonProcessing(btn, false, 'Revoke Issuer Role'); }
    }

    // ---------------------- URL Hash -> Verify Deep Link ----------------------
    async function checkForUrlHash(){
      const p = new URLSearchParams(window.location.search); const ch = p.get('certHash');
      if(ch){ switchTab('verify'); qs('#verifyHashInput').value = ch; }
    }

    // ---------------------- Particles ----------------------
    function initParticles(){ particlesJS('particles-js', { particles:{ number:{ value:60, density:{ enable:true, value_area:800 } }, color:{ value:'#ffffff' }, shape:{ type:'circle' }, opacity:{ value:0.8, random:true, anim:{ enable:true, speed:1, opacity_min:0.1, sync:false } }, size:{ value:3, random:true }, line_linked:{ enable:true, distance:150, color:'#ffffff', opacity:0.2, width:1 }, move:{ enable:true, speed:3, random:true, out_mode:'out' } }, interactivity:{ detect_on:'canvas', events:{ onhover:{ enable:true, mode:'grab' }, onclick:{ enable:true, mode:'push' }, resize:true }, modes:{ grab:{ distance:140, line_linked:{ opacity:0.5 } } } }, retina_detect:true }); }

    // ---------------------- Diagnostics / Self-tests ----------------------
    async function runSelfTests(){
      const out = [];
      try{
        // Test 1: Hashing known vector "abc"
        const expected = '0xba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad';
        const blob = new Blob(['abc'], { type: 'text/plain' });
        const got = await generateHashFromFile(blob);
        out.push(`Hash test: ${got === expected ? '‚úÖ' : '‚ùå'} (${got})`);
      }catch(e){ out.push('Hash test error: ' + e.message); }

      // Test 2: Provider detection
      const provider = selectEthereumProvider();
      out.push(`Provider present: ${provider ? '‚úÖ' : '‚ùå'}`);
      if(provider){ out.push(`isMetaMask: ${provider.isMetaMask ? 'yes' : 'no'}`); }

      // Test 3: Placeholder guard
      const placeholdersOK = contractAddress.includes('YOUR_NEW_SMART_CONTRACT_ADDRESS') || !(Array.isArray(abi) && abi.length>0);
      out.push(`Contract config set: ${placeholdersOK ? '‚ùå (needs address/ABI)' : '‚úÖ'}`);

      // Test 4: Pinata storage r/w
      try{ localStorage.setItem('__test__','1'); const v = localStorage.getItem('__test__'); localStorage.removeItem('__test__'); out.push(`localStorage: ${v==='1'?'‚úÖ':'‚ùå'}`); }catch(e){ out.push('localStorage error'); }

      qs('#diag').innerHTML = out.map(l=>`‚Ä¢ ${l}`).join('<br>');
    }

    // ---------------------- Events ----------------------
    window.addEventListener('DOMContentLoaded', ()=>{
      initParticles(); loadPinataFromStorage(); checkForUrlHash(); runSelfTests();

      // Tabs
      qsa('.tab').forEach(b=> b.addEventListener('click', ()=> switchTab(b.dataset.tab)));

      // Buttons
      qs('#connectButton').addEventListener('click', connectWallet);
      qs('#settingsButton').addEventListener('click', ()=> openSettings());
      qs('#closeSettingsBtn').addEventListener('click', closeSettings);
      qs('#testPinataBtn').addEventListener('click', testPinata);
      qs('#savePinataBtn').addEventListener('click', savePinata);
      qs('#clearPinataBtn').addEventListener('click', clearPinata);
      qs('#closeNoProviderBtn').addEventListener('click', ()=>{ qs('#noProviderModal').style.display='none'; });

      qs('#issueCertBtn').addEventListener('click', issueCert);
      qs('#verifyBtn').addEventListener('click', verifyCert);
      qs('#refreshHistoryBtn').addEventListener('click', fetchIssuedCertificates);
      qs('#historySearch').addEventListener('input', filterHistory);
      qs('#grantRoleBtn').addEventListener('click', grantRole);
      qs('#revokeRoleBtn').addEventListener('click', revokeRole);
      qs('#addToBatchBtn').addEventListener('click', addToBatch);
      qs('#csvFileInput').addEventListener('change', handleFileUpload);
      qs('#copyLinkBtn').addEventListener('click', copyLink);
      qs('#downloadQRBtn').addEventListener('click', downloadQR);
      qs('#shareQRBtn').addEventListener('click', shareQR);

      // Dropzone wiring
      const dz = qs('#dropzone'); const fi = qs('#fileInput');
      dz.addEventListener('click', ()=> fi.click());
      dz.addEventListener('dragover', e=>{ e.preventDefault(); dz.classList.add('drag'); });
      dz.addEventListener('dragleave', ()=> dz.classList.remove('drag'));
      dz.addEventListener('drop', e=>{ e.preventDefault(); dz.classList.remove('drag'); const f = e.dataTransfer.files[0]; fi.files = e.dataTransfer.files; handleFileChosen(f); });
      fi.addEventListener('change', e=> handleFileChosen(e.target.files[0]));

      // Set deep links
      const mmLink = metamaskDeepLink();
      qs('#openInMM').href = mmLink;
    });
  </script>
</body>
</html>
